[{"title":"C语言——结构体","path":"2021/10/14/C-结构体/","text":"1.结构体的定义与使用 结构体是一种构造数据类型 把不同类型的数据组合成一个整体 结构体的定义形式： 123struct 结构体名&#123; 结构体所包含的变量或数组&#125;; 结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个例子： 1234567struct stu&#123; char name[]; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125;; 注意：大括号后面的分号;不能少，这是一条完整的语句。 stu 为结构体名，它包含了 5 个成员，分别是 name、num、age、group、score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。 结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。像 int、float、char 等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为复杂数据类型或构造数据类型。 先定义结构体类型，再定义结构体变量12345678910 struct student &#123; int num; char name[20]; char sex; int age; float score; char addr[30]; &#125;; struct student stu1,stu2; 定义结构体类型的同时定义结构体变量12345struct data&#123; int day int month; int year&#125;time1,time2; 直接定义结构体变量1234567 struct &#123; char name[20]; char sex; int num; float score[3] &#125;person1,person2; 2.结构体变量的初始化 和其它类型变量一样，对结构体变量可以在定义时指定初始值。 1234567891011121314#include &lt;stdio.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book = &#123;&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456&#125;; int main()&#123; printf(&quot;title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n&quot;, book.title, book.author, book.subject, book.book_id);&#125;输出结果： 1234title : C 语言author: RUNOOBsubject: 编程语言book_id: 123456 3.访问结构成员为了访问结构的成员，我们使用成员访问运算符（.）。 引用形式：&lt;结构体类型变量名&gt;.&lt;成员名&gt; 注意：结构体变量不能整体引用，只能引用变量成员 成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法： 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125; stu1; //给结构体成员赋值 stu1.name = &quot;Tom&quot;; stu1.num = 12; stu1.age = 18; stu1.group = &#x27;A&#x27;; stu1.score = 136.5; //读取结构体成员的值 printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n&quot;, stu1.name, stu1.num, stu1.age, stu1.group, stu1.score); return 0;&#125; 运行结果：Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！ 除了可以对成员进行逐一赋值，也可以在定义时整体赋值，例如： 1234567struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1, stu2 = &#123; &quot;Tom&quot;, 12, 18, &#x27;A&#x27;, 136.5 &#125;; 不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。 需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储。 4.结构作为函数参数可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。例如： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include&lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; void printBook(struct Books book);//函数声明 int main()&#123; struct Books Book1;//声明Book1,类型为Books struct Books Book2; /* Book1 详述 */ strcpy(Book1.title, &quot;C Programming&quot;); strcpy(Book1.author, &quot;Nuha Ali&quot;); strcpy(Book1.subject, &quot;C Programming Tutorial&quot;); Book1.book_id = 6495407; printBook(Book1); return 0;&#125;void printBook(struct Books book)&#123; printf(&quot;Book title:%s\\n&quot;, book.title); printf(&quot;Book author:%s\\n&quot;, book.author); printf(&quot;Book subject:%s\\n&quot;, book.subject); printf(&quot;Book book_id:%d\\n&quot;, book.book_id);&#125; 运行结果： 1234Book title:C ProgrammingBook author:Nuha AliBook subject:C Programming TutorialBook book_id:6495407 5.结构体数组所谓结构体数组，是指数组中的每个元素都是一个结构体。在实际应用中，结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。 定义结构体数组和定义结构体变量的方式类似，请看下面的例子： 12345678struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;class[5];//表示一个班有5个人 结构体数组在定义的同时也可以初始化，例如： 12345678910111213struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;class[5] = &#123; &#123;&quot;Li ping&quot;, 5, 18, &#x27;C&#x27;, 145.0&#125;, &#123;&quot;Zhang ping&quot;, 4, 19, &#x27;A&#x27;, 130.5&#125;, &#123;&quot;He fang&quot;, 1, 18, &#x27;A&#x27;, 148.5&#125;, &#123;&quot;Cheng ling&quot;, 2, 17, &#x27;F&#x27;, 139.0&#125;, &#123;&quot;Wang ming&quot;, 3, 17, &#x27;B&#x27;, 144.5&#125;&#125;; 当对数组中全部元素赋值时，也可以不给出数组长度，如： 12345678910111213struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;class[] = &#123; &#123;&quot;Li ping&quot;, 5, 18, &#x27;C&#x27;, 145.0&#125;, &#123;&quot;Zhang ping&quot;, 4, 19, &#x27;A&#x27;, 130.5&#125;, &#123;&quot;He fang&quot;, 1, 18, &#x27;A&#x27;, 148.5&#125;, &#123;&quot;Cheng ling&quot;, 2, 17, &#x27;F&#x27;, 139.0&#125;, &#123;&quot;Wang ming&quot;, 3, 17, &#x27;B&#x27;, 144.5&#125;&#125;; 结构体数组的使用也很简单。例如，计算全班学生的总成绩、平均成绩和140分一下的人数： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;class[] = &#123; &#123;&quot;Li ping&quot;, 5, 18, &#x27;C&#x27;, 145.0&#125;, &#123;&quot;Zhang ping&quot;, 4, 19, &#x27;A&#x27;, 130.5&#125;, &#123;&quot;He fang&quot;, 1, 18, &#x27;A&#x27;, 148.5&#125;, &#123;&quot;Cheng ling&quot;, 2, 17, &#x27;F&#x27;, 139.0&#125;, &#123;&quot;Wang ming&quot;, 3, 17, &#x27;B&#x27;, 144.5&#125;&#125;; int main()&#123; int i, num_140 = 0; float sum = 0; for(i=0; i&lt;5; i++)&#123; sum += class[i].score; if(class[i].score &lt; 140) num_140++; &#125; printf(&quot;sum=%.2f\\naverage=%.2f\\nnum_140=%d\\n&quot;, sum, sum/5, num_140); return 0;&#125; 运行结果： 123sum=707.50average=141.50num_140=2 6.指向结构的指针可以定义指向结构的指针，方式与定义指向奇特类型变量的指针类似， 定义形式：struct 结构体名 *结构体指针名; 1struct Books *struct_pointer; 定义之后可以在上述定义的指针变量中存储结构变量的地址。例： 1struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，必须使用-&gt;运算符，如下所示： 1struct_pointer-&gt;title; 定义结构体指针的实例： 123456789struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; &quot;Tom&quot;, 12, 18, &#x27;A&#x27;, 136.5 &#125;;//结构体指针struct stu *pstu = &amp;stu1; 也可以在定义结构体的同时定义结构体指针： 1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; &quot;Tom&quot;, 12, 18, &#x27;A&#x27;, 136.5 &#125;, *pstu = &amp;stu1; 注意：结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp;符号，所以给p赋值只能写成 1struct stu *p=&amp;stu1; 而不能写成： 1struct stu *p=stu1; 注意：结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。下面的写法是错误的，不可能去取一个结构体名的地址，也不能将它赋值给其他变量： 12struct stu *pstu = &amp;stu;struct stu *p=stu; 7.获取结构体成员通过结构体指针可以获取结构体成员，一般形式为: 1(*pointer).memberName 或者： 1pointer-&gt;memberName 第一种写法中，.的优先级高于，(pointer)两边的括号不能少，如果去掉括号写成pointer.memberName,那么就等效于(pointer.memberName),这样意义就不对了。 第二种写法中，-&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员，这也是-&gt;在C语言中的唯一用途。 上面两种写法是等效的，我们通常采用第二种写法，这样更加直观。 实例：结构体指针的使用 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125; stu1 = &#123; &quot;Tom&quot;, 12, 18, &#x27;A&#x27;, 136.5 &#125;, *pstu = &amp;stu1; //读取结构体成员的值 printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n&quot;, (*pstu).name, (*pstu).num, (*pstu).age, (*pstu).group, (*pstu).score); printf(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n&quot;, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age, pstu-&gt;group, pstu-&gt;score); return 0;&#125; 运行结果： 12Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！ 示例：结构体数组指针的使用 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;stus[] = &#123; &#123;&quot;Zhou ping&quot;, 5, 18, &#x27;C&#x27;, 145.0&#125;, &#123;&quot;Zhang ping&quot;, 4, 19, &#x27;A&#x27;, 130.5&#125;, &#123;&quot;Liu fang&quot;, 1, 18, &#x27;A&#x27;, 148.5&#125;, &#123;&quot;Cheng ling&quot;, 2, 17, &#x27;F&#x27;, 139.0&#125;, &#123;&quot;Wang ming&quot;, 3, 17, &#x27;B&#x27;, 144.5&#125;&#125;, *ps; int main()&#123; //求数组长度 int len = sizeof(stus) / sizeof(struct stu); printf(&quot;Name\\t\\tNum\\tAge\\tGroup\\tScore\\t\\n&quot;); for(ps=stus; ps&lt;stus+len; ps++)&#123; printf(&quot;%s\\t%d\\t%d\\t%c\\t%.1f\\n&quot;, ps-&gt;name, ps-&gt;num, ps-&gt;age, ps-&gt;group, ps-&gt;score); &#125; return 0;&#125; 运行结果： 123456Name Num Age Group ScoreZhou ping 5 18 C 145.0Zhang ping 4 19 A 130.5Liu fang 1 18 A 148.5Cheng ling 2 17 F 139.0Wang ming 3 17 B 144.5"},{"title":"C语言——字符串","path":"2021/10/11/C-字符串/","text":"字符串操作strcpy(p, p1) 复制字符串strncpy(p, p1, n) 复制指定长度字符串strcat(p, p1) 附加字符串strncat(p, p1, n) 附加指定长度字符串strlen(p) 取字符串长度strcmp(p, p1) 比较字符串strcasecmp忽略大小写比较字符串strncmp(p, p1, n) 比较指定长度字符串strchr(p, c) 在字符串中查找指定字符strrchr(p, c) 在字符串中反向查找strstr(p, p1) 查找字符串strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 字符串到数值类型的转换strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型atoi(p) 字符串转换到 int 整型atof(p) 字符串转换到 double 符点数atol(p) 字符串转换到 long 整型 字符检查isalpha() 检查是否为字母字符isupper() 检查是否为大写字母字符islower() 检查是否为小写字母字符isdigit() 检查是否为数字isxdigit() 检查是否为十六进制数字表示的有效字符isspace() 检查是否为空格类型字符iscntrl() 检查是否为控制字符ispunct() 检查是否为标点符号isalnum() 检查是否为字母和数字isprint() 检查是否是可打印字符isgraph() 检查是否是图形字符，等效于 isalnum() | ispunct() 函数原型原型：strcpy(char destination[], const char source[]);功能：将字符串source拷贝到字符串destination中例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[10] = &#123; &quot;TsinghuaOK&quot;&#125;; char str2[10] = &#123; &quot;Computer&quot;&#125;; cout &lt;&lt;strcpy(str1,str2)&lt;&lt;endl; &#125; 运行结果是:Computer第二个字符串将覆盖掉第一个字符串的所有内容！注意：在定义数组时，字符数组1的字符串长度必须大于或等于字符串2的字符串长度。不能用赋值语句将一个字符串常量或字符数组直接赋给一个字符数组。所有字符串处理函数都包含在头文件string.h中。 原型：strncpy(char destination[], const char source[], int numchars);功能：将字符串source中前numchars个字符拷贝到字符串destination中 例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[10] = &#123; &quot;Tsinghua &quot;&#125;; char str2[10] = &#123; &quot;Computer&quot;&#125;; cout &lt;&lt;strncpy(str1,str2,3)&lt;&lt;endl; &#125; 运行结果：Comnghua注意：字符串source中前numchars个字符将覆盖掉字符串destination中前numchars个字符！ 原型：strcat(char target[], const char source[]);功能：将字符串source接到字符串target的后面例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[] = &#123; &quot;Tsinghua &quot;&#125;; char str2[] = &#123; &quot;Computer&quot;&#125;; cout &lt;&lt;strcpy(str1,str2)&lt;&lt;endl; &#125; 运行结果：Tsinghua Computer 注意：在定义字符数组1的长度时应该考虑字符数组2的长度，因为连接后新字符串的长度为两个字符串长度之和。进行字符串连接后，字符串1的结尾符将自动被去掉，在结尾串末尾保留新字符串后面一个结尾符。 原型：strncat(char target[], const char source[], int numchars);功能：将字符串source的前numchars个字符接到字符串target的后面例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[] = &#123; &quot;Tsinghua &quot;&#125;; char str2[] = &#123; &quot;Computer&quot;&#125;; cout &lt;&lt;strncat(str1,str2,3)&lt;&lt;endl; &#125; 运行结果：Tsinghua Com 原型：int strcmp(const char firststring[], const char secondstring);功能：比较两个字符串firststring和secondstring例程： 12345678910111213141516171819#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char buf1[] = &quot;aaa&quot;; char buf2[] = &quot;bbb&quot;; char buf3[] = &quot;ccc&quot;; int ptr; ptr = strcmp(buf2,buf1); if(ptr &gt; 0) cout &lt;&lt;&quot;Buffer 2 is greater than buffer 1&quot;&lt;&lt;endl; else cout &lt;&lt;&quot;Buffer 2 is less than buffer 1&quot;&lt;&lt;endl; ptr = strcmp(buf2,buf3); if(ptr &gt; 0) cout &lt;&lt;&quot;Buffer 2 is greater than buffer 3&quot;&lt;&lt;endl; else cout &lt;&lt;&quot;Buffer 2 is less than buffer 3&quot;&lt;&lt;endl; &#125; 运行结果是: Buffer 2 is less than buffer 1 Buffer 2 is greater than buffer 3 原型：strlen( const char string[] );功能：统计字符串string中字符的个数例程： 123456789#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str[100]; cout &lt;&lt;&quot;请输入一个字符串:&quot;; cin &gt;&gt;str; cout &lt;&lt;&quot;The length of the string is :&quot;&lt;&lt;strlen(str)&lt;&lt;&quot;个&quot;&lt;&lt;endl; &#125; 运行结果The length of the string is x (x为你输入的字符总数字) 注意：strlen函数的功能是计算字符串的实际长度，不包括’\\0’在内。另外，strlen函数也可以直接测试字符串常量的长度，如：strlen(“Welcome”)。 void *memset(void *dest, int c, size_t count);将dest前面count个字符置为字符c. 返回dest的值. void *memmove(void *dest, const void *src, size_t count);从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理. 返回dest的值. void *memcpy(void *dest, const void *src, size_t count);从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠. 返回dest的值. void *memchr(const void *buf, int c, size_t count);在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回NULL. void *_memccpy(void *dest, const void *src, int c, size_t count);从src复制0个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止. 如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回NULL. int memcmp(const void *buf1, const void *buf2, size_t count);比较buf1和buf2前面count个字节大小.返回值&lt; 0, 表示buf1小于buf2;返回值为0, 表示buf1等于buf2;返回值&gt; 0, 表示buf1大于buf2. int memicmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2前面count个字节. 与memcmp不同的是, 它不区分大小写. 返回值同上. char *strrev(char *string);将字符串string中的字符顺序颠倒过来. NULL结束符位置不变. 返回调整后的字符串的指针. char *_strupr(char *string);将string中所有小写字母替换成相应的大写字母, 其它字符保持不变. 返回调整后的字符串的指针. char *_strlwr(char *string);将string中所有大写字母替换成相应的小写字母, 其它字符保持不变. 返回调整后的字符串的指针. char *strchr(const char *string, int c);查找字 串string中首次出现的位置, NULL结束符也包含在查找中. 返回一个指针, 指向字符c在字符串string中首次出现的位置, 如果没有找到, 则返回NULL. char *strrchr(const char *string, int c);查找字符c在字符串string中最后一次出现的位置, 也就是对string进行反序搜索, 包含NULL结束符.返回一个指针, 指向字符c在字符串string中最后一次出现的位置, 如果没有找到, 则返回NULL. char *strstr(const char *string, const char *strSearch);在字符串string中查找strSearch子串. 返回子串strSearch在string中首次出现位置的指针. 如果没有找到子串strSearch, 则返回NULL. 如果子串strSearch为空串, 函数返回string值. char *strdup(const char *strSource);函数运行中会自己调用malloc函数为复制strSource字符串分配存储空间, 然后再将strSource复制到分配到的空间中. 注意要及时释放这个分配的空间.返回一个指针, 指向为复制字符串分配的空间; 如果分配空间失败, 则返回NULL值. char *strcat(char *strDestination, const char *strSource);将源串strSource添加到目标串strDestination后面, 并在得到的新串后面加上NULL结束符. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 在字符串的复制或添加过程中没有溢出检查, 所以要保证目标串空间足够大. 不能处理源串与目标串重叠的情况. 函数返回strDestination值. char *strncat(char *strDestination, const char *strSource, size_t count);将源串strSource开始的count个字符添加到目标串strDest后. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 如果count大于源串长度, 则会用源串的长度值替换count值. 得到的新串后面会自动加上NULL结束符. 与strcat函数一样, 本函数不能处理源串与目标串重叠的情况. 函数返回strDestination值. char *strcpy(char *strDestination, const char *strSource);复制源串strSource到目标串strDestination所指定的位置, 包含NULL结束符. 不能处理源串与目标串重叠的情况.函数返回strDestination值. char *strncpy(char *strDestination, const char *strSource, size_t count);将源串strSource开始的count个字符复制到目标串strDestination所指定的位置. 如果count值小于或等于strSource串的长度, 不会自动添加NULL结束符目标串中, 而count大于strSource串的长度时, 则将strSource用NULL结束符填充补齐count个字符, 复制到目标串中. 不能处理源串与目标串重叠的情况.函数返回strDestination值. char *strset(char *string, int c);将string串的所有字符设置为字符c, 遇到NULL结束符停止. 函数返回内容调整后的string指针. char *strnset(char *string, int c, size_t count);将string串开始count个字符设置为字符c, 如果count值大于string串的长度, 将用string的长度替换count值. 函数返回内容调整后的string指针. size_t strspn(const char *string, const char *strCharSet);查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置序号. 返回一个整数值, 指定在string中全部由characters中的字符组成的子串的长度. 如果string以一个不包含在strCharSet中的字符开头, 函数将返回0值. size_t strcspn(const char *string, const char *strCharSet);查找strCharSet串中任何一个字符在string串中首次出现的位置序号, 包含字符串结束符NULL.返回一个整数值, 指定在string中全部由非characters中的字符组成的子串的长度. 如果string以一个包含在strCharSet中的字符开头, 函数将返回0值. char *strspnp(const char *string, const char *strCharSet);查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置指针. 返回一个指针, 指向非strCharSet中的字符在string中首次出现的位置. char *strpbrk(const char *string, const char *strCharSet);查找strCharSet串中任何一个字符在string串中首次出现的位置, 不包含字符串结束符NULL.返回一个指针, 指向strCharSet中任一字符在string中首次出现的位置. 如果两个字符串参数不含相同字符, 则返回NULL值. int strcmp(const char *string1, const char *string2);比较字符串string1和string2大小.返回值&lt; 0, 表示string1小于string2;返回值为0, 表示string1等于string2;返回值&gt; 0, 表示string1大于string2. int stricmp(const char *string1, const char *string2);比较字符串string1和string2大小，和strcmp不同, 比较的是它们的小写字母版本.返回值与strcmp相同. int strcmpi(const char *string1, const char *string2);等价于stricmp函数, 只是提供一个向后兼容的版本. int strncmp(const char *string1, const char *string2, size_t count);比较字符串string1和string2大小，只比较前面count个字符. 比较过程中, 任何一个字符串的长度小于count, 则count将被较短的字符串的长度取代. 此时如果两串前面的字符都相等, 则较短的串要小.返回值&lt; 0, 表示string1的子串小于string2的子串;返回值为0, 表示string1的子串等于string2的子串;返回值&gt; 0, 表示string1的子串大于string2的子串. int strnicmp(const char *string1, const char *string2, size_t count);比较字符串string1和string2大小，只比较前面count个字符. 与strncmp不同的是, 比较的是它们的小写字母版本. 返回值与strncmp相同. char *strtok(char *strToken, const char *strDelimit);在strToken 串中查找下一个标记, strDelimit字符集则指定了在当前查找调用中可能遇到的分界符. 返回一个指针, 指向在strToken中找到的下一个标记. 如果找不到标记, 就返回NULL值. 每次调用都会修改strToken内容, 用NULL字符替换遇到的每个分界符."},{"title":"C语言——指针","path":"2021/10/11/C-指针/","text":"一、指针的概念要知道指针的概念，要先了解变量在内存中如何存储的。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。 1.1、变量和地址先写一段简单的代码 123void main()&#123; int x = 10, int y = 20;&#125; 这段代码非常简单，就是两个变量的声明，分别赋值了 10、20。我们把内存当做一个酒店，而每个房间就是一块内存。那么“int x = 10;”和“int y = 20;”的实际含义如下： 1、去酒店订了两个房间，门牌号暂时用 px、py 表示 2、让 10 住进 px，让 20 住进 py 3、其中门牌号就是 px、py 就是变量的地址 4、x 和 y 在这里可以理解为具体的房间，房间 x 的门牌号（地址）是 px，房间 y 的门牌号（地址）是 py。而 10 和 20，通过 px、py 两个门牌，找到房间，住进 x、y。 1.2、指针变量和指针的类型指针变量就是一个变量，它存储的内容是一个指针。如果用前面的例子，可以理解为指针变量就是一张房卡，房卡存储了房间号的信息。 在我们定义一个变量的时候，要确定它的类型。int x、char ch、float、、、在定义指针变量时也是一样的，必须确定指针类型。int 变量的指针需要用 int 类型的指针存储，float 变量的指针需要用 float 类型的指针存储。就像你只能用酒店 A 的房卡存储酒店 A 中房间号的信息一样。 二、指针与变量变量的指针就是变量的存储地址，指针变量就是存储指针的变量。 2.1、指针变量的定义及使用（1）指针变量的定义指针变量的定义形式如：数据类型 *指针名;例如： 1234//分别定义了 int、float、char 类型的指针变量int *x;float *f;char *ch; 如上面的定义，指针变量名为 x、f、ch。并不是x、f、*ch （2）指针变量的使用 取地址运算符&amp;：单目运算符&amp;是用来取操作对象的地址。例：&amp;i 为取变量 i 的地址。对于常量表达式、寄存器变量不能取地址（因为它们存储在存储器中，没有地址）。 指针运算符（间接寻址符）：与&amp;为逆运算，作用是通过操作对象的地址，获取存储的内容。例：x = &amp;i，x 为 i 的地址，x 则为通过 i 的地址，获取 i 的内容 12345678//声明了一个普通变量 aint a;//声明一个指针变量，指向变量 a 的地址int *pa;//通过取地址符&amp;，获取 a 的地址，赋值给指针变量pa = &amp;a;//通过间接寻址符，获取指针指向的内容printf(&quot;%d&quot;, *pa); （3）“&amp;”和“*”的结合方向“&amp;”和“”都是右结合的。假设有变量 x = 10，则&amp;x 的含义是，先获取变量 x 的地址，再获取地址中的内容。因为“&amp;”和“*”互为逆运算，所以 x = *&amp;x。 接下来做个小练习，输入 x、y 两个整数，然后将其中的值大的赋值给 x，小的赋值给 y。即：假设输入 x = 8，y = 9。就将 9 赋值给 x，8 赋值给 y。 12345678910111213141516171819202122void main()&#123; //声明两个普通变量 int x, y; //声明两个指针变量 int *px, *py; //声明一个临时变量，用于交换 int t; //输入两个值，赋值给 x、y scanf(&quot;%d&quot;, &amp;x); scanf(&quot;%d&quot;, &amp;y); //给指针变量 px、py 赋初值（关联变量 x、y） px = &amp;x; py = &amp;y; //利用指针来对比 x、y 的值，如果 x 的值比 y 的值小，就交换 if(*px &lt; *py)&#123; //交换步骤，其中*px == x、*py == y t = *px; *px = *py; *py = t; &#125; printf(&quot;x = %d, y = %d&quot;, *px, *py);&#125; 12输入：23 45输出结果为：x = 45, y = 23 2.2、指针变量的初始化指针变量与其它变量一样，在定义时可以赋值，即初始化。也可以赋值“NULL”或“0”，如果赋值“0”，此时的“0”含义并不是数字“0”，而是 NULL 的字符码值。 1234567int *px, *py, *pz, x = 10;//赋予某个变量的地址px = &amp;x;//相互赋值py = px;//赋值具体的地址pz = 4000; 2.3、指针运算（1）赋值运算指针变量可以互相赋值，也可以赋值某个变量的地址，或者赋值一个具体的地址 1234567int *px, *py, *pz, x = 10;//赋予某个变量的地址px = &amp;x;//相互赋值py = px;//赋值具体的地址pz = 4000; （2）指针与整数的加减运算 指针变量的自增自减运算。指针加 1 或减 1 运算，表示指针向前或向后移动一个单元（不同类型的指针，单元长度不同）。这个在数组中非常常用。 指针变量加上或减去一个整形数。和第一条类似，具体加几就是向前移动几个单元，减几就是向后移动几个单元。12345678910111213//定义三个变量，假设它们地址为连续的，分别为 4000、4004、4008int x, y, z;//定义一个指针，指向 xint *px = &amp;x;//利用指针变量 px 加减整数，分别输出 x、y、zprintf(&quot;x = %d&quot;, *px); //因为 px 指向 x，所以*px = x//px + 1，表示，向前移动一个单元（从 4000 到 4004）//这里要先(px + 1)，再*(px + 1)获取内容，因为单目运算符“*”优先级高于双目运算符“+”printf(&quot;y = %d&quot;, *(px + 1)); printf(&quot;z = %d&quot;, *(px + 2)); （3）关系运算 假设有指针变量 px、py。 1、px &gt; py 表示 px 指向的存储地址是否大于 py 指向的地址2、px == py 表示 px 和 py 是否指向同一个存储单元3、px == 0 和 px != 0 表示 px 是否为空指针 12345678910111213141516171819202122//定义一个数组，数组中相邻元素地址间隔一个单元int num[2] = &#123;1, 3&#125;;//将数组中第一个元素地址和第二个元素的地址赋值给 px、pyint *px = &amp;num[0], *py = &amp;num[1];int *pz = &amp;num[0];int *pn;//则 py &gt; pxif(py &gt; px)&#123; printf(&quot;py 指向的存储地址大于 px 所指向的存储地址&quot;);&#125;//pz 和 px 都指向 num[0]if(pz == px)&#123; printf(&quot;px 和 pz 指向同一个地址&quot;);&#125;//pn 没有初始化if(pn == NULL || pn == 0)&#123; printf(&quot;pn 是一个空指针&quot;);&#125; 三、指针与数组之前我们可以通过下标访问数组元素，学习了指针之后，我们可以通过指针访问数组的元素。在数组中，数组名即为该数组的首地址，结合上面指针和整数的加减，我们就可以实现指针访问数组元素。 3.1、指向数组的指针如以下语句： 1int nums[10], *p; 上面语句定义了一个数组 nums，在定义时分配了 10 个连续的int 内存空间。而一个数组的首地址即为数组名nums，或者第一个元素的首地址也是数组的首地址。那么有两种方式让指针变量 p 指向数组 nums： 1234//数组名即为数组的首地址p = nums;//数组第一个元素的地址也是数组的首地址p = &amp;nums[0]; 上面两句是等价的。 如下几个操作，用指针操作数组： 1、*p = 1，此操作为赋值操作，即将指针指向的存储空间赋值为 1。此时 p 指向数组 nums 的第一个元素，则此操作将 nums 第一个元素赋值为 0，即 nums[0] = 1。2、p + 1，此操作为指针加整数操作，即向前移动一个单元。此时 p + 1 指向 nums[0]的下一个元素，即 nums[1]。通过p + 整数可以移动到想要操作的元素（此整数可以为负数）。3、如上面，p（p + 0）指向 nums[0]、p + 1 指向 nums[1]、、、类推可得，p+i 指向 nums[i]，由此可以准确操作指定位置的元素。4、在 p + 整数的操作要考虑边界的问题，如一个数组长度为 2，p+3 的意义对于数组操作来说没有意义。 下面写一段代码，用指针访问数组的元素： 12345678910111213141516//定义一个整形数组，并初始化int nums[5] = &#123;4, 5, 3, 2, 7&#125;;//定义一个指针变量 p，将数组 nums 的首地址赋值给 p，也可以用p = &amp;nums[0]赋值int *p = nums, i; //i 作为循环变量//p 指向数组第一个元素（数组首地址），我们可以直接用间接寻址符，获取第一个元素的内容printf(&quot;nums[0] = %d\\n&quot;, *p); //输出结果为 nums[0] = 4//我们可以通过“p + 整数”来移动指针，要先移动地址，所以 p + 1 要扩起来printf(&quot;nums[1] = %d\\n&quot;, *(p + 1)); //输出结果为 nums[1] = 5//由上面推导出*(p + i) = nums[i]，所以我们可以通过 for 循环变量元素for(i = 0; i &lt; 5; i++)&#123; printf(&quot;nums[%d] = %d&quot;, i, *(p + i));&#125; 注：数组名不等价于指针变量，指针变量可以进行 p++和&amp;操作，而这些操作对于数组名是非法的。数组名在编译时是确定的，在程序运行期间算一个常量。 3.2、字符指针与字符数组在 C 语言中本身没有提供字符串数据类型，但是可以通过字符数组和字符指针的方式存储字符串。 （1）字符数组方式这个在前面应该学习过，这里就不赘述了。 12char word[] = &quot;zack&quot;;printf(&quot;%s&quot;, word); （2）字符指针方式指针方式操作字符串和数组操作字符串类似，可以把定义的指针看做是字符数组的数组名。在内存中存储大致如下，这里为了方便换了个字符串： 123456789101112//除了定义一个字符数组外，还可以直接定义一个字符指针存储字符串char *sentence = &quot;Do not go gentle into that good night!&quot;;//此时可以做字符串的操作//输出printf(&quot;%s&quot;, sentence);//通过下标取字符printf(&quot;%c&quot;, sentence[0]);//获取字符串长度，其中 strlen 是 string.h 库中的方法printf(&quot;%d&quot;, strlen(sentence)); 注：字符指针方式区别于字符数组方式，字符数组不能通过数组名自增操作，但是字符指针是指针，可以自增操作。自增自减少会实现什么效果大家可以自己尝试运行一下 下面做个小练习，利用字符指针将字符数组 sentence 中的内容复制到字符数组 word 中： 123456789101112131415161718//定义字符数组 sentence 和 word，给 sentence 赋初值char sentence[] = &quot;Do not go gentle into that good night!&quot;, word[100];//定义字符指针，指向 wordchar *ch = word;int i;//循环赋值for(i = 0; sentence[i] != &#x27;\\0&#x27;; i++)&#123; *(ch + i) = sentence[i];&#125;//在当 i 等于 sentence 的长度（sentence 的长度不包含&#x27;\\0&#x27;）时，//i 继续自增，此时判断 sentence[0] != &#x27;\\0&#x27;不符合，跳出循环，则 i 比 sentence 长度大 1*(ch + i) = &#x27;\\0&#x27;;//输出字符串，因为 ch 指向 word，所以输出结果是一样的printf(&quot;ch = %s, word = %s&quot;, ch, word); 注：指针变量必须初始化一个有效值才能使用 3.3、多级指针及指针数组（1）多级指针指针变量作为一个变量也有自己的存储地址，而指向指针变量的存储地址就被称为指针的指针，即二级指针。依次叠加，就形成了多级指针。我们先看看二级指针，它们关系如下： 其中 p 为一级指针，pp 为二级指针。二级指针定义形式如下： 1数据类型 **二级指针名; 和指针变量的定义类似，由于是右结合的，所以pp 相当于*(p)。在本次定义中，二级指针的变量名为 pp，而不是**p。多级指针的定义就是定义时使用多个“”号。下面用一个小程序举例： 12345678910111213141516//定义普通变量和指针变量int *pi, i = 10;//定义二级指针变量int **ppi;//给指针变量赋初值pi = &amp;i;//给二级指针变量赋初值ppi = &amp;pi;//我们可以直接用二级指针做普通指针的操作//获取 i 的内容printf(&quot;i = %d&quot;, **ppi);//获取 i 的地址printf(&quot;i 的地址为%d&quot;, *ppi); 注：在初始化二级指针 ppi 时，不能直接 ppi = &amp;&amp;i，因为&amp;i 获取的是一个具体的数值，而具体数字是没有指针的。 （2）指针数组指针变量和普通变量一样，也能组成数组，指针数组的具体定义如下： 1数据类型 *数组名[指针数组长度]; 举一个简单的例子熟悉指针数组： 1234567891011121314151617181920212223242526//定义一个数组int nums[5] = &#123;2, 3, 4, 5, 2&#125;, i;//定义一个指针数组int *p[5];//定义一个二级指针int **pp;//循环给指针数组赋值for(i = 0; i &lt; 5; i++)&#123; p[i] = &amp;nums[i];&#125;//将指针数组的首地址赋值给 pp，数组 p 的数组名作为 p 的首地址，也作为 p 中第一个元素的地址。//数组存放的内容为普通变量，则数组名为变量的指针；数组存放的内容为指针，则数组名为指针的指针。pp = p;//利用二级指针 pp 输出数组元素for(i = 0; i &lt; 5; i++)&#123; //pp == &amp;p[0] == &amp;&amp;nums[0]，nums[0] == *p[0] == **pp printf(&quot;%d&quot;, **pp); //指针变量+整数的操作，即移动指针至下一个单元 pp++;&#125; 3.4、指针与多维数组讲多维数组是个麻烦的事，因为多维数组和二维数组没有本质的区别，但是复杂度倒是高了许多。这里我主要还是用二维数组来举例，但是还是会给大家分析多维数组和指针的关系。 （1）多维数组的地址先用一个简单的数组来举例： 1234int nums[2][2] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;&#125;; 我们可以从两个维度来分析：1、先是第一个维度，将数组当成一种数据类型 x，那么二维数组就可以当成一个元素为 x 的一维数组。2、如上面的例子，将数组看成数据类型 x，那么 nums 就有两个元素。nums[0]和 nums[1]。3、我们取 nums[0]分析。将 nums[0]看做一个整体，作为一个名称可以用 x1 替换。则 x1[0]就是 nums[0][0]，其值为 1。 我们知道数组名即为数组首地址，上面的二维数组有两个维度。首先我们把按照上面 1 来理解，那么 nums 就是一个数组，则nums 就作为这个数组的首地址。第二个维度还是取 nums[0]，我们把 nums[0]作为一个名称，其中有两个元素。我们可以尝试以下语句： 1printf(&quot;%d&quot;, nums[0]); 此语句的输出结果为一个指针，在实验过后，发现就是 nums[0][0]的地址。即数组第一个元素的地址。 如果再多一个维度，我们可以把二维数组看做一种数据类型 y，而三维数组就是一个变量为 y 的一维数组。而数组的地址我们要先确定是在哪个维度，再将数组某些维度看成一个整体，作为名称，此名称就是该维度的地址（这里有些绕）。 例： 1234567891011 //假设已初始化，二维数组数据类型设为 x，一维数组数据类型设为 yint nums[2][2][2];//此数组首地址为该数组名称printf(&quot;此数组首地址为%d&quot;, nums);//此数组可以看做存储了两个 x 类型元素的一维数组，则 nums[0] = x1 的地址为printf(&quot;第二个维度的首地址为%d&quot;, nums[0]);//而 x1 可以看做存储了两个 y 类型元素的一维数组，则 y1 = x1[0] = nums[0][0]printf(&quot;第三个维度的首地址为%d&quot;, nums[0][0]);三维数组实际存储形式如下：实际存储内容的为最内层维度，且为连续的。对于 a 来说，其个跨度为 4 个单元；对 a[0]来说，其跨度为 2 个单元；对 a[0][0]来说，跨度为一个单元。有上面还可以得出： 1a == a[0] == a[0][0] == &amp;a[0][0][0]; 上面的等式只是数值上相等，性质不同。 （2）多维数组的指针在学习指针与数组的时候，我们可以如下表示一个数组： 12int nums[5] = &#123;2, 4, 5, 6, 7&#125;;int *p = nums; 在前面讲指针数组时，所有指针数组元素都指向一个数字，那么我们现在可以尝试用指针数组的每个元素指向一个数组： 12345678910111213141516171819//定义一个二维数组int nums[2][2] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;&#125;;//此时 nums[0]、和 nums[1]各为一个数组int *p[2] = &#123;nums[0], nums[1]&#125;;//我们可以用指针数组 p 操作一个二维数组//p 为数组 p 的首地址，p[0] = nums[0] = *p，**p = nums[0][0]printf(&quot;nums[0][0] = %d&quot;, **p);//指针 + 整数形式，p+1 移动到 nums 的地址，*(p +1) = nums[1]，则**(p + 1) = nums[1][0]printf(&quot;nums[1][0] = %d&quot;, **(p + 1));//先*p = nums[0]，再*p + 1 = &amp;nums[0][1]，最后获取内容*(*p + 1)即为 nums[0][1]printf(&quot;nums[0][1] = %d&quot;, *(*p + 1)); 这里可能不能理解为什么p + 1 = &amp;nums[0][1]，而不是 nums[1]。p 获得的是一个一维数组，而 int 数组 + 1 的跨度只有 4 个字节，也就是一个单元。前面 p 是一维数组的指针，其跨度为一个数组。所以*p + 1 = &amp;nums[0][1]，而 p + 1 = nums[1]。 四、指针与函数前面学习函数学到，函数参数可以为 int、char、float 等，但是在操作时，这些参数只作为形参，所有操作都只在函数体内有效（除对指针的操作外），那么今天来学习一下指针作为函数参数。 4.1、函数参数为指针我们直接做一个练习，定义一个函数，用来交换两个变量的内容。 123456789101112void swap(int *x, int *y);void main()&#123; int x = 20, y = 10; swap(&amp;x, &amp;y); printf(&quot;x = %d, y = %d&quot;, x ,y);&#125;void swap(int *x, int *y)&#123; int t; t = *x; *x = *y; *y = t;&#125; 代码非常简单，我也就不细讲了。这里传入的参数为指针，所以调用 swap 方法后 x，y 的内容发生了交换。如果直接传入 x，y，那么交换只在 swap 中有效，在 main 中并没有交换。 4.2、函数的返回值为指针返回值为指针的函数声明如下： 123456789数据类型 *函数名(参数列表)&#123; 函数体&#125;//例如：int s;int *sum(int x, int y)&#123; s = x + y; return &amp;s;&#125; 在函数调用前要声明需要对函数声明（有点编译器不需要） 123456789int s;void mian()&#123; int *r = sum(10, 9); printf(&quot;10 + 9 + %d&quot;, *r);&#125;int *sum(int x, int y)&#123; s = x + y; return &amp;s;&#125; 除了上面的操作，更实用的是返回一个指向数组的指针，这样就实现了返回值为数组。 4.3、指向函数的指针C 语言中，函数不能嵌套定义，也不能将函数作为参数传递。但是函数有个特性，即函数名为该函数的入口地址。我们可以定义一个指针指向该地址，将指针作为参数传递。 函数指针定义如下： 1数据类型 (*函数指针名)(); 函数指针在进行“*”操作时，可以理解为执行该函数。函数指针不同与数据指针，不能进行+整数操作。 下面举个例子，来使用函数指针： 1234567891011121314151617181920212223#include &lt;string.h&gt;/*** 定义一个方法，传入两个字符串和一个函数指针 p，用 p 对两个字符串进行操作*/void check(char *x, char *y, int (*p)());void main()&#123; //string.h 库中的函数，使用之前需要声明该函数。字符串比较函数 int strcmp(); char x[] = &quot;Zack&quot;; char y[] = &quot;Rudy&quot;; //定义一个函数指针 int (*p)() = strcmp; check(x, y, p);&#125;void check(char *x, char *y, int (*p)())&#123; if(!(*p)(x, y))&#123; printf(&quot;相等&quot;); &#125;else&#123; printf(&quot;不相等&quot;); &#125;&#125; 利用函数指针调用方法具体操作如下： 1(*p)(x, y);"},{"title":"C语言——函数","path":"2021/10/09/C-函数/","text":"一、函数的概念函数要先定义再使用！！！函数要先定义再使用！！！函数要先定义再使用！！！ 1、 为什么要用函数 避免代码冗长 模块化设计思路 按功能划分，每个函数代表一个功能，二函数的名字要体现函数的功能意义，类似变量标识符y=f(x) 2、函数三要素 函数名体现功能 参数列表比如y=f(x)，x就是参数比如z=f(x,y)，x，y就是参数。参数的个数根据需求自定义 返回值比如y=f(x)，y是函数根据x的值和f的功能执行后的结果 3、函数体 执行什么样的功能，涉及的处理代码叫做函数体。 4、结构化程序设计的思想：把大问题分解成若干个小问题，每个小问题就是一个独立的子模块，以实现特定的功能、在C程序中，子模块的作用是由函数完成的. 一个c源程序可以由多个文件构成（c文件的后缀名.c） 一个源文件是一个编译单位 一个源文件可以由若干个函数组成（函数是c程序的基本组成单位） 每个c程序只能有一个main函数，其他都是子函数。 主函数可以调用子函数，子函数可以相互多次调用。 二、函数的分类1、按函数的定义分类1.1、标准函数标准函数又称为库函数，由c系统提供，无需程序员定义，可直接使用,但需要在程序开头包含原型声明的头文件。如scanf() 1.2、自定义函数由程序员根据自己的需求编写，自定义函数不仅要在程序中定义函数本身，必须还要在主函数中调用该函数 2、按有无返回值的分类2.1、有返回值函数该类函数被调用执行完毕，将向调用者返回一个执行结果，称为函数的返回值 123456789101112 int send( int a,int b)&#123;return a+b;&#125; void main()&#123;z=send(a,b);printf(&quot;%d\\n&quot;,z); &#125; 2.2、无返回值的函数无返回值函数不需要向主调函数提供返回值 123456789void printstar() &#123;printf(&quot;************&quot;);&#125;void main()&#123; printsar();&#125; 3、按函数的形式分类3.1、无参函数在函数的声明、定义和调用中均不带参数，特点：在调用无参函数主调函数并不将数据传输给被调用函数，此类函数通常被用来完成指定的功能，可以返回或不返回函数值。 12345678910111213141516171819202122/*格式： 类型说明 函数名() &#123; // 函数体 &#125; */int max()&#123;// 函数体&#125; 空函数 无函数体类型说明 函数名() &#123;//无函数体 因程序设计需要,确定模块需求 先占位置 后在补上 &#125; int max()&#123; &#125; 3.2、有参函数在函数定义、声明都都有参数。特点：主调函数调用被调函数时，主调函数必须把值传输给形参，以供被调函数使用 1234 int max(int a,int b) // 有参函数&#123;函数体&#125; 4、形式参数和实际参数1、说明 在定义函数时，函数名后面括号中的变量名称为“形式参数”（简称“形参”）或“虚拟参数”。在主调用函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”（简称“实参”）。实参可以是常量，变量和表达式。 2、传递参数 传递参数传递的时值。形参和实参的值是相同的，但地址空间不同。 3、局部变量 在函数A中定义变量a，b，又在函数B中定义了变量a，b。A函数中的变量a，b和B函数中的变量a，b不是同一个对象 局部变量的生命周期保存在栈空间，被调用的时候才会为形式参数申请内存，调用结束后，内存会被系统释放。 三、函数调用 C程序是从主函数main()开始执行的，以main()函数体结束为止在函数体的执行过程中，通过不断地对函数的调用来执行的。 调用者 被称为主调函数一般为main()函数， 被调用者 称为被调函数一般为自定义函数或者库函数。 被调函数执行结束，从被调函数结束的位置再返回主调函数当中，继续执行主调函数后面的语句。 1、函数的调用过程 1、内存空间在定义函数中指定的形参，在未出现调用函数时，它们并不占用内存中的储存单元。在发生函数调用时，函数的形参会被临时分配内存单元。 2、值传递将实参对应的值传递给形参 3、值返回通过return语句将函数值带回到主调函数 4、内存释放调用结束，形参单元被释放 2、函数的调用方式1、(函数语句)第一种调用方式 123函数名(实参列表); 函数名(); 2、(函数表达式)第二种调用方式 123m=max(x,y); // 将max()函数的返回值赋值给变量mm=3*max(x,y); // 将max()函数的返回值乘3赋值给变量mprintf(&quot;Max is %d,max(x,y)&quot;); // 输出max()函数的返回值 3、函数调用的条件 函数已被定义 调用库函数 #include&lt;stdio.h&gt; 函数的声明用户自己定义的函数如果在调用他的函数（主调函数）的后面，应在主调函数中对被调函数作声明。 4、函数的嵌套一步步调用，一步步退出在c语言中，函数的关系是平行的，是独立的即函数的不能嵌套定义。 c语言中函数的嵌套调用即在调用一个函数的过程中可以调用另外一个函数。 六、内部函数和外部函数1、内部函数如果在一个源文件中定义的函数只能被文件中的函数调用，而不能被同一源程序其他文件中的函数调用。 内部函数的一般形式 123456789101112static 类型说明符 函数名([形参表]) [ ]中的部分为可选项 内部函数关键字：static static int f(int a,int b) // 内部函数&#123; &#125; f()函数只能被本文件中的函数调用，其他文件中不能使用该函数. 2、外部函数外部函数在整个源程序中都有效，只要定义函数时，在前面加上extern关键字 123456789101112131415定义形式 extern 类型说明符 函数名 (&lt;形参表&gt;) extern int f(int a,int b)&#123; &#125; 不带extern与static关键字的函数都是外部函数如: int voo() // 外部函数int vi()&#123; // 外部函数 &#125;"},{"title":"C语言——数组","path":"2021/10/08/C-数组/","text":"一维数组定义一个数组类型符 数组名[常量表达式] ; 1、相同数据类型 定义的时候表示数组中元素的总个数——int temp[10]; 下标法表示数组中的某个元素，从0开始计数； 2、数组数组如何遍历 下标法访问 结合循环语句 地址连续的 3、初始化方式 全部赋值在定义数组时对全部的数组元素赋予初值int temp[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; 部分赋值可以只给数组中一部分元素赋值int temp[10]=&#123;0,1,2,3,4&#125;; 初始化成0数组中数值全部为0int temp[10]=0; 见怪不怪可不指定数组长度int temp[]=&#123;0,1,2,3&#125; sizeof()关键字sizeof()能计算括号中对应数据的内存空间大小。把整个数组的大小，除以数组中一个元素的大小，就能获得总个数。size = sizeof(temp)/sizeof(temp[0]) 冒泡排序法 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main()&#123; int array[] = &#123;12,3,29,7&#125;; int i; int j; int tmp; int len = sizeof(array)/sizeof(array[0]); for(i=0;i&lt;len-1;i++) &#123; for(j=0;j&lt;len-1-i;j++) &#123; if(array[j] &gt; array[j+1]) //从小到大 &#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125; for(i=0;i&lt;len;i++) &#123; printf(&quot;%d&quot;,array[i]); &#125;&#125; 简单选择排序法 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main()&#123; int array[] = &#123;12,3,29,7&#125;; int i; int j; int tmp; int len = sizeof(array)/sizeof(array[0]); for(i=0;i&lt;len-1;i++) &#123; for(j=i+1;j&lt;len;j++) &#123; if(array[i] &gt; array[j]) //从小到大 &#123; tmp = array[i]; array[i]= array[j]; array[j] = tmp; &#125; &#125; &#125; for(i=0;i&lt;len;i++) &#123; printf(&quot;%d&quot;,array[i]); &#125;&#125; 二维数组1、定义一个二维数组二维数组常称之为矩阵。二维数组写成行和列的排序形式，可以有助于形象化地理解二位数组的逻辑结构。 类型说明符 数组名 [常量表达式] [常量表达式]；例如：float a[3][4],b[5][10]; 定义a为3x4的数组，b为5x10的数组； 2、二维数组初始化 只对各行第一列的元素赋初值，其余元素自动为0.int a[3][4]=&#123;&#123;1&#125;,&#123;5&#125;,&#123;9&#125;&#125;; 对各行中的某一元素进行赋初值int a[3][4]=&#123;&#123;1&#125;,&#123;0,6&#125;,&#123;0,0,11&#125;&#125;; 对某几行元素赋初值int a[3][4]=&#123;&#123;1&#125;,&#123;5,6&#125;&#125;; 对全部元素赋初值int a[3][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;与下面的定义等价：int a[][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;//可以不写行，一定要写列 3、二位数组找最大值及对应下表 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main()&#123; int i,j,hang,lie,max; int arry[3][4] = &#123;1,12,54,32,48,89,78,31,66,13,44,33&#125;; for(i=0;i&lt;3;i++) &#123; for(j=0;j&lt;4;j++) &#123; printf(&quot;%d \\t&quot;,arry[i][j]); &#125; printf(&quot;\\n&quot;) &#125; max = arry[0][0]; for(i=0;i&lt;3;i++) &#123; for(j=0;j&lt;4;j++) &#123; if(max &lt; arry[i][j]) &#123; max = arry[i][j]; hang = i; lie = j; &#125; &#125; &#125; printf(&quot;其中在第%d行第%d列的数%d最大\\n&quot;,hang+1,lie+1,max);&#125;"},{"title":"C语言——流程控制","path":"2021/10/08/C-流程控制/","text":"C语言语句类型：1、表达式语句包括：运算符表达式语句、赋值语句。 2、流程控制语句包括结构化语句和非结构语句； A.结构化语句包括：条件语句和循环语句； 条件语句包括：if语句和switch语句； 循环语句包括：while语句、do while语句和for语句。 B.非结构化语句包括：限定转向语句和非限定转向语句； 限定转向语句：break语句、continue语句和return语句； 非限定转向语句：goto语句。 3、函数调用语句 4、空语句 5、复合语句 结构化程序设计的核心是算法和控制结构。算法：解决问题时的一系列方法和步骤；主要表示方法：伪代码和流程图。 算法的步骤间有一定的逻辑顺序，此体现为控制结构。分为：顺序结构、分支结构和循环结构。 （1）顺序结构：最简单、最基本，从上往下执行，不进行跳转； 1234567形式：语句1；语句2；语句3； 执行顺序：语句1；》语句2；》语句3；…….. （2）分支结构：有3种：单分支、双分支和多分支；即选择结构，根据条件判断执行程序，成立则执行，反之不执行。 （3）循环结构：当型循环和直到型循环。用于一遍一遍执行程序的某部分，根据条件判断是否执行，重复执行多少次。循环结构：循环条件和循环体 一、条件语句A.if语句a.判断表达式： 1234567 if（判断表达式） &#123; 结构体；&#125; 例子： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;conio.h&gt; //使用getchvoid main(void)&#123; int price=0; printf(&quot;请输入商品价格：&quot;); scanf(&quot;%d&quot;,&amp;price); if(price&lt;50) &#123; printf(&quot;好，我买了&quot;); &#125; getch();&#125; b.花括号和if结构体 123456(1)if（表达式） &#123; 语句1； 语句2； 语句3； &#125; 和 (2)if（表达式） 等价于 if（表达式） 语句1； &#123;语句1；&#125; 语句2； 语句2； 语句3； 语句3； if后边并非必须跟“&#123;&#125;”，如（1）中if条件满足，&#123;&#125;中的块语句都执行；（2）中if条件满足，才执行语句1，语句2和语句3都会执行。 B.if else语句两个选择 123456789形式：if（表达式）&#123; 代码段1&#125;else&#123; 代码段2&#125; if后边的表达式为真，执行代码段1，否则执行代码段2。 例子： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int price=0; printf(&quot;请输入商品价格：&quot;); scanf(&quot;%d&quot;,&amp;price); if(price&lt;50) &#123; printf(&quot;好，买了&quot;); &#125; else &#123; printf(&quot;不买&quot;); &#125; getch();&#125; C.if else语句和swich语句多个选择 1234567891011121314151617if（表达式1）&#123; 代码段1&#125;else if（表达式2）&#123; 代码段2&#125; ···else if（表达式m）&#123; 代码段m&#125;else&#123; 代码段m+1&#125; 例子： 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int a=0; printf(&quot;请输入学生成绩：\\n&quot;); scanf(&quot;%d&quot;,&amp;a); if(a&gt;=90) printf(&quot;A&quot;); if(a&gt;=75 &amp;&amp; a&lt;90) printf(&quot;B&quot;); if(a&gt;=60 &amp;&amp; a&lt;75) printf(&quot;C&quot;); if(a&lt;60) printf(&quot;D&quot;);&#125; D.分支语句嵌套形式： 1234567891011if（表达式1）&#123; if（表达式2） &#123; 代码段1 &#125; else &#123; 代码段2 &#125;&#125; E.开关语句：switch语句多选一形式： 123456789101112131415switch（表达式）&#123; case:（常量表达式1）； 代码段1 break； case:（常量表达式2）； 代码段2 break； …… case:（常量表达式m）； 代码段m break； default： 代码段m+1&#125; 二、循环语句A. while 语句（当型）形式： 12345678910111213141516171819202122232425 while (表达式) &#123; 循环结构体 &#125;``` While语句后边的```&#123;&#125;```为循环体，如果直接跟着```“；”```，说明在while后边表达式为真时，执行空语句，直到表达式为零，跳出while语句。例子：```c#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int sum=0; int i=1; while(i&lt;=100) &#123; sum=sum+i; i=i+1; &#125; printf(&quot;结果是：%d&quot;,sum); getch();&#125; B. do while 语句 （直到型）形式： 12345do&#123; 循环结构体&#125;while（表达式）； //有分号 do while结构中的循环结构体至少会被执行一次，直到while后的表达式非零，跳出do while结构向下执行。 例子： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int sum=0; int i=100;/* while(i) &#123; sum=sum+i; i--; &#125; */ do &#123; sum=sum+i; i=i-1; &#125; while(i); printf(&quot;结果是：%d&quot;,sum); getch();&#125; C. for 语句 （当型） 形式： 1234 for(初始化表达式；判断表达式；修正表达式)&#123; 循环体&#125; 等价于while结构： 12345while（判断表达式）&#123; 循环体 修正表达式；&#125; for语句比较简洁，其执行过程： a. 计算初始化表达式； b. 计算判断表达式的值，如果其值为真（非0），则执行循环体，并执行c步骤；若为假，则循环结束，转到e步骤； c. 计算修正表达式； d. 转回b步骤执行； e. 循环结束，跳出for循环，向下执行。 注意：for中的表达式可以省略，但是“；；”不能省略； 即： 12345678for( ；；)&#123; ···&#125;``` 等价于 ```cwhile（1） 例子： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int i,j; for(i=1; i&lt;=4;i++) //外层循环4次 &#123; for(j=1; j&lt;=9;j++) //内层循环9次 &#123; printf(&quot;* &quot;); //后边带俩个空格 &#125; printf(&quot;\\n&quot;); &#125; getch();&#125; 注意：一般内循环次数多余外循环。 D. 跳出循环：break可从死循环中跳出来 适用于3种循环结构，只能用于switch语句，不能跳出if语句和if else语句 例子： 123456789101112131415#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int i=0; while(1) &#123; printf(&quot;Hello\\n&quot;); i++; if(i&gt;5) break; &#125; getch();&#125; E. 重来一次： continuebreak用于结束整个循环结构，而continue语句结束的只是当前一次循环，只是结束本次循环中后续内容，被称为循环继续语句。 F. 随心所欲：goto即：go to，为自由转向语句，可以跳转到任何地方； 形式：goto+标号名 例子： 123456789101112131415#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main(void)&#123; int i=0; while(1)&#123; printf(&quot;* &quot;); i++; if(i&gt;3) //0到3，输出4个*，退出* goto outside;&#125;outside:printf(&quot;\\n\\n\\n* &quot;);&#125;"},{"title":"C语言——数据认知","path":"2021/10/06/C-数据/","text":"一、printf函数；printf（格式控制，输出列表） 格式声明 原样输出printf(&quot;hello world&quot;); %占位符/格式符printf(&quot;a=%d&quot;,a); d——十进制 c——单个字符——输出一个字母 s——多个字符 f——小数——指定位数 %m.nf x——以16进制格式输出 p——一般打印内存地址，也就是16进制格式输出——输出地址，取变量地址的运算符号&amp; 输出列表 数据类型 表达式 二、scanf函数/扫描键盘scanf（格式控制，地址列表） 地址符号&amp; ：scanf函数中的“格式控制”后面应当是变量地址，而不是变量名 scanf(&quot;%f,%f,%f,&amp;a,&amp;b,&amp;c&quot;); 原样输入 ：如果在“格式控制字符串”中除了格式声明以外还有其他字符，则在输入数据时在对应的位置上输入与这些字符相同的字符。如果有：scanf(&quot;a=%f,b=%f,c=%f,&amp;a,&amp;b,&amp;c&quot;);在输入输入数据时，应在对应的位置输入同样的字符。即输入a=1，b=2,c=3 注意字符在用%c格式声明输入字符时，“空格字符”和“转义字符”中的字符都作为有效字符输入。 混合输入在输入数据数值时，如输入空格，回车，tap键或遇非法字符（不属于数值的字符），认为该数据结束。例如：scanf(&quot;%d%c%f&quot;,&amp;a,&amp;b,&amp;c); 三、其他 getchar putchar puts gets puts跟printf的区别 1.自动加入换行符 2.printf支持多种输出，而puts就是输出字符串 四、练习 1.例：键盘输入大写字母输出相应的小写字母 123456789101112131415161718#include&lt;stdio.h&gt;&#123;char a = &#x27;a&#x27;;char A = &#x27;A&#x27;;cahr b;printf(&quot;%c,%c\\n&quot;,a,A);printf(&quot;%d,%d\\n&quot;,a,A);puts(&quot;请输入一个大写字母\\n&quot;);scanf(&quot;%c&quot;,&amp;b);printf(&quot;对应的小写字母是 %c&quot;，b+32);printf(&quot;测试&quot;)；getchar();//吸收回车符，来源于scanf。当你分多次连续scanf获得字符的时候，要注意回车符。putchar(getchar()+32);return 0;&#125; 将“China”编译成原来字母后面第四个字母代替的字母，即“China” -&gt;“Glmre”。分别用putchar函数和printf函数输出。 1234567891011121314151617#include &lt;stdio.h&gt; int main() &#123; char a,b,c,d,e; printf(&quot;please\\n&quot;); scanf(&quot;%c%c%c%c%c%c&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); printf(&quot;print: %c%c%c%c%c\\n&quot;,a+4,b+4,c+4,d+4,e+4); printf(&quot;text: &quot;); putchar(a+4); putchar(b+4); putchar(c+4); putchar(d+4); putchar(e+4); return 0; &#125;"},{"title":"C语言——初识变量","path":"2021/10/06/C-变量/","text":"C语言的基础框架 1、一个c语音程序有且只有一个main函数，且必须有一个main函数主函数 2、注释不参与编译和执行，只是给别人看的。 3、C程序是由函数构成的，函数是c程序的基本单位，编写c程序也就是编写一个个函数（模块化）。 4、一个函数由两部分组成：1 函数的首部，包括函数类型，函数名，函数参数类型，函数参数名。2函数体，花括号部分。 5、程序=数据结构+算法 数据结构：对数据的描述，数据类型和数据的组织形式 算法：对操作的描述，即操作步骤 数据类型 1、变量的属性：声明一条变量，同时给他赋初值int a=0；等价于int a;a=0;从这个例子我们可以看到： 第一个属性：变量是有值的。我们给他赋值为0，就相当于他的内存单元里边存的是0，不再是随机数了。 第二个属性：变量的名，a就是他的名字。 第三个属性：变量的地址，你存到哪里了？值存在哪里？ 第四个属性：变量被分配的内存大小；因为不是整个内存都归他管，你到底占多大的内存空间呢？有一个分配的内存大小。 2、变量的类型决定了变量被分配内存空间的大小。内存是计算机内的存储部件，代码和数据都存在其中。 3、内存的特点：所有指令和数据都保存在内存里，速度快，可随机访问，但掉电即失去（掉电就没了）。 4、变量的类型决定了什么？ 占用内存空间的大小； 数据的存储形式；(在Inter 的CPU上面，这个整型数他的存储是低位字节在前高位字节在后，相当于脚先进去；实型数的存储稍微复杂一点，我们通常说是定点数，但是在计算机中保存是按照浮点数来保存的；) 合法的取值范围； 可参与的运算种类； 5、C语言中的数据类型被分为两大类： （1）基本数据类型：处理一个一个数据的，单个数据的这么一种数据类型。 （2）构造数据类型：可以把若干个基本数据类型的数据组织起来，形成一个更加复杂的一个类型。 C语言提供的基本数据类型有： 6、有符号和无符号： 解释成有符号数的话最高位是符号位，符号位为1的时候表明它是一个负数；为0的时候表示他是一个正数。但是如果把它解释成一个无符号数的话，最高位呢就作为一个数据位，而不是一个符号位了，所以就不再是表示正负的问题了，他都作为一个数据位来解释了。 整型int型：代表整数，包含正整数和负整数。 声明变量： 12//声明int变量int num; 初始化变量：（未被初始化的变量，其值为随机数（乱码）） 12//初始化int变量int num=5; int类型的常量：不含小数点和指数的数字，一般都是一个整型的常量。 整型的常量在C语言当中可以有三种表示方法：十进制、八进制和十六进制。 输出： 123456//以十进制输出printf(&quot;%d&quot;,num);//以8进制输出printf(&quot;%o&quot;,num);//以16进制输出printf(&quot;%x&quot;,num); 其他的整型类型： short int可以简写为short；如果程序里处理的这个整数比较小，可以把它看成是一个short int类型的；如果说这一个变量是一个short int类型，那么我们在输出的时候就在输出的这个格式控制符之前加上一个h;short int类型的变量也可以用8进制、10进制和16进制输出，那么他对应的格式控制字符呢就是hd,ho,hx;这就表示以10进制输出一个短整型数，以8进制输出一个短整型数，以16进制输出一个短整型数。 输出短整型： 1printf(&quot;%hd,%ho,hx&quot;,num,num,num) long int 长整型，就是比整型表示范围更大的一个整型类型 输出长整型：123L(数字后面的L就表示是长整型，告诉编译器我把这个整数看成是长整型的，而不是int类型）。 假如说在我这个编译器里边长整型是占用8个字节，那在输出的时候你就要告诉printf函数你不是取4个字节，你应该取8个字节的值来输出，我们用一个字母“l”来表示,长整型数同样是可以用8进制、16进制来表示，但是输出的时候呢我们在格式控制符前边加上一个l； 输出长整型： 1printf(&quot;%ld,%lo,lx&quot;,num,num,num); unsigned int、unsigned short、unsigned long 无符号，都是整数（非负整数） 输出无符号整型： 12//对应输出unsigned int、unsigned short、unsigned long;printf(&quot;%u,%hu,%lu&quot;,num,snum,lnum); 字符型 变量声明：（字符类型用关键字 char表示）1char ch; 输出字符：（用格式控制字符%c） 注意单引号5和整数5的区别：&#39;5&#39;是一个字符型和整数5它是一个整型 1234char ch=&#x27;a&#x27;;printf(&quot;%c&quot;,ch);//屏幕上将会显示a(相当于%c用a代替)printf(&quot;%d&quot;,ch);//输出97，相当于使用的是内码输出printf(&quot;%c\\n%c&quot;,ch,ch);//输出一个a之后换行再输出一个a 奇偶校验 奇偶校验指代码输出过程中是否出现错误。奇偶校验规定，若一个字节编码序列中1的个数是奇数，则校验位置1，否则置0，偶校验与其正好相反。 ASCII码 ASCII码是有127个，但是我们一个字节可以表示255个，还剩下127个，所以我们有了ASCII码的扩展码，ASCII扩展码就是利用了他的最高位，把他的最高位不用做奇偶校验。利用他的最高位来使他的值在128到255之间，也定义了一些相关的字符；ASCII码的扩展码包括英文制表符、部分音标字符和其他字符。 上边是英文字符我们表示成功了，那么汉字怎么存储呢？英文字符使用的是一个字节，汉字使用几个字节呢？汉字使用两个字节。那我怎么区分存储在内存中的这两个字节是两个字符呢还是一个汉字呢？汉字也有编码，为了兼容ASCII码，那我们规定，连续两个字节他的第7位都为1的时候就是一个汉字，就和ASCII码区别啦。 浮点型浮点型是专门用来处理实数的工具。实数在计算机里面是用浮点的形式来表示的，所以我们把它称之为浮点类型。 声明浮点变量： 浮点类型：float（单精度实型）、double、long double（这三个类型和int、short、long 是一样的，float是处理比较小的实型数，double是处理一般的实型数，long double是处理比较大的实型数） 1234//声明浮点变量float x1,x2；\\\\声明的时候赋初值float x1=2.7,x2;//声明之后x1的值就是2.7，x2的值就是一个随机数。 浮点型常量： 如果说一个实型数的值已经定了，那我们可以把这个实型数直接写在程序里边，这就是浮点型的常量； 12345678十进制表示：123.456 -0.879科学计数法表示1.5E18 1.5x10^18float类型的常量表示123.456F -0.188flong double类型的常量表示123.465L -0.188l 浮点数输出 %f：十进制输出 123456float f1 = 123.2 double d1 = 1.5E3printf(&quot;%f %f&quot;,f1,d1);123.199998 1500 %e:科学计数法表示 123456float f1 = 123.2 double d1 = 1.5E3printf(&quot;%e %e&quot;,f1,d1);1.232000e+002 1.500000e+003 %Lf,%Le:Long double 类型的常量表示 1234long double d1 = 1.5E3;printf(&quot;%Lf %Le&quot;,d1,d1)1500.000000 1.5000000e+003 float和double的精度： 采用单精度类型和双精度类型来存储浮点类型的数据时，假如float占用32bit，double数据占用64bit时，那么我们在声明一个变量float a=2.55的时候，是如何进行内存分配的呢？如果胡乱毫无规则的分配就会乱套。其实不管是float还是double在存储方式上都是遵从IEEE的规范的，float遵从的是IEEE R32.24，而double遵从的是R64.53。 由上边数据类型的介绍我们知道，单精度还是双精度在存储中都分为3部分： （1）符号位(sign)：0代表正，1代表负； （2）指数位(exponent)：用于存储科学计数法中的指数数据，并且采用移位存储； （3）尾数部分(mantissa)：尾数部分； 12345678910float： double:1bit（符号位） 1bit（符号位）； 8bit（指数位） 11bit（指数位）;23bit（尾数位\\有效数字位）； 52bit（尾数位）；共32位； 共64位；"},{"title":"C语言——基于Vscode开发环境搭建","path":"2021/10/05/C-环境/","text":"要在VSCode中配置C语言环境，我们首先可能要一个VSCode（废话），所以先下载安装一个VSCode；然后肯定需要相关插件，因为VSCode不能直接拿来写C；然后任何语言的程序在运行前都需要编译，那还需要一个编译器，很可惜VSCode插件里面不自带，所以要自己下载然后配置；最后在VSCode中进行相关配置，就可以啦 1. VsCode（system版） VsCode vscode插件 Chinese（simplifled）Language Pack ——官方汉化包 C/C++ （编辑器） 2.MinGW MinGW 下载完成后解压到你指定的文件夹： 然后配置环境变量 找到这个文件夹内的一个叫bin的文件夹： 然后把它的地址复制一下，找到此电脑（或者我的电脑）——&gt;右键——&gt;属性 然后进入到下面这个页面，打开高级系统设置： 在弹出的页面中选择“高级”分页，找到环境变量，单击打开： 然后在环境变量中的系统变量中，找到Path变量： 打开之后将刚刚复制的地址添加进去： 然后测试环境配置是否成功：crtl+R快捷键打开运行窗口，在里面输入cmd，回车打开cmd.exe在cmd.exe中输入如下命令：gcc -v -E -x c++ -如果运行结果像下方图片中这样，就配置成功了: 3.工程搭建先新建一个文件夹作为C语言项目文件，然后点击菜单栏中的文件——&gt;打开文件夹，找到刚才新建的文件夹，然后点击选择文件夹打开这个项目文件。在里面新建一个text.c文件（名字随便起，以.c结尾就行了），然后再建一个.vscode文件夹（注意前面有个点）。c文件里面写入万恶之源”hello world”:打开终端输入 12gcc text.c ./a.exe 运行成功，走你！"},{"title":"基于mpvue框架搭建微信小程序","path":"2021/10/03/vue-weapp/","text":"一、环境配置1. 微信开发者工具（稳定版） 微信开发者工具 微信小程序官方文档 2. node.js node.js PowerShell输入命令node --version和npm --version检测是否安装成功。 1234PS C:\\WINDOWS\\system32&gt; node --versionv16.10.0PS C:\\WINDOWS\\system32&gt; npm --version7.24.1 3. Vue-CLI 🛠️ Vue.js 开发的标准工具 可以使用下列任一命令安装这个新的包：npm install -g @vue/cli 运行vue --version命令来检查其版本是否正确: 12PS C:\\WINDOWS\\system32&gt; vue --version@vue/cli 4.5.13如需升级全局的 Vue CLI 包，请运行： npm update -g @vue/cli 如需卸载全局的 Vue CLI 包，请运行： npm uninstall vue-cli -g 4. VsCode（system版） VsCode vscode插件 Chinese（simplifled）Language Pack ——官方汉化包 minapp ——小程序格式化 vetur ——vue语法格式化 vscode-icons ——vscode ide 文件图标（可选） Bracket Pair Colorizer 2 ——花括号代码高亮（可选） 二、工程搭建1.环境检测再次运行命令node --version、npm --version、vue --version 检测环境是否安装完整: 123456PS C:\\WINDOWS\\system32&gt; node --versionv16.10.0PS C:\\WINDOWS\\system32&gt; npm --version7.24.1PS C:\\WINDOWS\\system32&gt; vue --version@vue/cli 4.5.13 2.工程生成 mvpue快速上手在vscode的终端中执行vue init mpvue/mpvue-quickstart my-project命令快速搭建工程: 123456789101112131415Windows PowerShell版权所有（C） Microsoft Corporation。保留所有权利。安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindowsPS E:\\&gt; vue init mpvue/mpvue-quickstart my-project ? Project name my-project? wxmp appid touristappid? Project description A Mpvue project? Author dushiyi2333 &lt;1061133261@qq.com&gt;? Vue build runtime? Use Vuex? No? Use ESLint to lint your code? No? 小程序测试，敬请关注最新微信开发者工具的“测试报告”功能 执行以下命令运行工程： 进入创建工程文件夹 cd my-project 安装依赖 npm install 运行程序 npm run dev1DONE Compiled successfully in 2247ms 走你！"},{"title":"月明星稀","path":"2021/10/03/hello-world/","text":"道德是一种自律，而不是他律。"}]